"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;
var _kleur = _interopRequireDefault(require("kleur"));
var _path = _interopRequireDefault(require("path"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _which = _interopRequireDefault(require("which"));
var _crossSpawn = _interopRequireDefault(require("cross-spawn"));
var _del = _interopRequireDefault(require("del"));
var _json = _interopRequireDefault(require("json5"));
var _os = require("os");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
async function build({
  source,
  root,
  output,
  report,
  options
}) {
  report.info(`Cleaning up previous build at ${_kleur.default.blue(_path.default.relative(root, output))}`);
  await (0, _del.default)([output]);
  report.info(`Generating type definitions with ${_kleur.default.blue('tsc')}`);
  const project = options?.project ? options.project : 'tsconfig.json';
  const tsconfig = _path.default.join(root, project);
  try {
    if (await _fsExtra.default.pathExists(tsconfig)) {
      try {
        const config = _json.default.parse(await _fsExtra.default.readFile(tsconfig, 'utf-8'));
        if (config.compilerOptions) {
          const conflicts = [];
          if (config.compilerOptions.declarationDir) {
            conflicts.push('compilerOptions.declarationDir');
          }
          if (config.compilerOptions.outDir && _path.default.join(root, config.compilerOptions.outDir) !== output) {
            conflicts.push('compilerOptions.outDir');
          }
          if (conflicts.length) {
            report.warn(`Found following options in the config file which can conflict with the CLI options. Please remove them from ${_kleur.default.blue(project)}:${conflicts.reduce((acc, curr) => acc + `\n${_kleur.default.gray('-')} ${_kleur.default.yellow(curr)}`, '')}`);
          }
        }
      } catch (e) {
        report.warn(`Couldn't parse '${project}'. There might be validation errors.`);
      }
    } else {
      throw new Error(`Couldn't find a ${_kleur.default.blue('tsconfig.json')} in the project root.`);
    }
    let tsc;
    if (options?.tsc) {
      tsc = _path.default.resolve(root, options.tsc);
      if (!(await _fsExtra.default.pathExists(tsc))) {
        throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed at ${_kleur.default.blue(tsc)}. Please specify the correct path in options or remove it to use the workspace's version.`);
      }
    } else {
      const execpath = process.env.npm_execpath;
      const cli = execpath?.split('/').pop()?.includes('yarn') ? 'yarn' : 'npm';
      if (cli === 'yarn') {
        const result = _crossSpawn.default.sync('yarn', ['bin', 'tsc'], {
          stdio: 'pipe',
          encoding: 'utf-8',
          cwd: root
        });
        tsc = result.stdout.trim();
      } else {
        tsc = _path.default.resolve(root, 'node_modules', '.bin', 'tsc');
      }
      if ((0, _os.platform)() === 'win32' && !tsc.endsWith('.cmd')) {
        tsc += '.cmd';
      }
    }
    if (!(await _fsExtra.default.pathExists(tsc))) {
      try {
        tsc = await (0, _which.default)('tsc');
        if (await _fsExtra.default.pathExists(tsc)) {
          report.warn(`Failed to locate ${_kleur.default.blue('tsc')} in the workspace. Falling back to the binary found in ${_kleur.default.blue('PATH')} at ${_kleur.default.blue(tsc)}. Consider adding ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specifying the ${_kleur.default.blue('tsc')} option for the typescript target.`);
        }
      } catch (e) {
        // Ignore
      }
    }
    if (tsc == null || !(await _fsExtra.default.pathExists(tsc))) {
      throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed under ${_kleur.default.blue('node_modules')} or present in $PATH. Make sure you have added ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specify the ${_kleur.default.blue('tsc')} option for typescript.`);
    }
    const tsbuildinfo = _path.default.join(output, project.replace(/\.json$/, '.tsbuildinfo'));
    try {
      await (0, _del.default)([tsbuildinfo]);
    } catch (e) {
      // Ignore
    }
    const outputs = options?.esm ? {
      commonjs: _path.default.join(output, 'commonjs'),
      module: _path.default.join(output, 'module')
    } : {
      commonjs: output
    };
    const result = _crossSpawn.default.sync(tsc, ['--pretty', '--declaration', '--declarationMap', '--noEmit', 'false', '--emitDeclarationOnly', '--project', project, '--outDir', outputs.commonjs], {
      stdio: 'inherit',
      cwd: root
    });
    if (result.status === 0) {
      await (0, _del.default)([tsbuildinfo]);
      if (outputs?.module) {
        // When ESM compatible output is enabled, we need to generate 2 builds for commonjs and esm
        // In this case we copy the already generated types, and add `package.json` with `type` field
        await _fsExtra.default.copy(outputs.commonjs, outputs.module);
        await _fsExtra.default.writeJSON(_path.default.join(outputs.commonjs, 'package.json'), {
          type: 'commonjs'
        });
        await _fsExtra.default.writeJSON(_path.default.join(outputs.module, 'package.json'), {
          type: 'module'
        });
      }
      report.success(`Wrote definition files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
      const pkg = JSON.parse(await _fsExtra.default.readFile(_path.default.join(root, 'package.json'), 'utf-8'));
      const fields = [{
        name: 'types',
        value: pkg.types,
        output: outputs.commonjs,
        error: false
      }, ...(pkg.exports?.['.']?.types ? [{
        name: "exports['.'].types",
        value: pkg.exports?.['.']?.types,
        output: outputs.commonjs,
        error: options?.esm === true
      }] : []), {
        name: "exports['.'].import.types",
        value: pkg.exports?.['.']?.import?.types,
        output: outputs.module,
        error: !options?.esm
      }, {
        name: "exports['.'].require.types",
        value: pkg.exports?.['.']?.require?.types,
        output: outputs.commonjs,
        error: !options?.esm
      }];
      const getGeneratedTypesPath = async field => {
        if (!field.output || field.error) {
          return null;
        }
        if (pkg.source) {
          const indexDTsName = _path.default.basename(pkg.source).replace(/\.(jsx?|tsx?)$/, '') + '.d.ts';
          const potentialPaths = [_path.default.join(field.output, _path.default.dirname(pkg.source), indexDTsName), _path.default.join(field.output, _path.default.relative(source, _path.default.join(root, _path.default.dirname(pkg.source))), indexDTsName)];
          for (const potentialPath of potentialPaths) {
            if (await _fsExtra.default.pathExists(potentialPath)) {
              return _path.default.relative(root, potentialPath);
            }
          }
        }
        return null;
      };
      const invalidFieldNames = (await Promise.all(fields.map(async field => {
        if (field.error) {
          if (field.value) {
            report.warn(`The ${_kleur.default.blue(field.name)} field in ${_kleur.default.blue(`package.json`)} should not be set when the ${_kleur.default.blue('esm')} option is ${options?.esm ? 'enabled' : 'disabled'}.`);
          }
          return null;
        }
        if (field.name.startsWith('exports') && field.value && !/^\.\//.test(field.value)) {
          report.error(`The ${_kleur.default.blue(field.name)} field in ${_kleur.default.blue(`package.json`)} should be a relative path starting with ${_kleur.default.blue('./')}. Found: ${_kleur.default.blue(field.value)}`);
          return field.name;
        }
        if (field.value && !(await _fsExtra.default.pathExists(_path.default.join(root, field.value)))) {
          const generatedTypesPath = await getGeneratedTypesPath(field);
          report.error(`The ${_kleur.default.blue(field.name)} field in ${_kleur.default.blue('package.json')} points to a non-existent file: ${_kleur.default.blue(field.value)}.\nVerify the path points to the correct file under ${_kleur.default.blue(_path.default.relative(root, output))}${generatedTypesPath ? ` (found ${_kleur.default.blue(generatedTypesPath)}).` : '.'}`);
          return field.name;
        }
        return null;
      }))).filter(name => name != null);
      if (invalidFieldNames.length) {
        throw new Error(`Found errors for fields: ${invalidFieldNames.join(', ')}.`);
      }
      const validFields = fields.filter(field => !field.error);
      if (validFields.every(field => field.value == null)) {
        const suggestedTypesPaths = (await Promise.all(validFields.map(field => getGeneratedTypesPath(field)))).filter(path => path != null).filter((path, i, self) => self.indexOf(path) === i);
        report.warn(`No ${validFields.map(field => _kleur.default.blue(field.name)).join(' or ')} field found in ${_kleur.default.blue('package.json')}. Consider ${suggestedTypesPaths.length ? `pointing to ${suggestedTypesPaths.map(path => _kleur.default.blue(path)).join(' or ')}` : `adding ${validFields.length > 1 ? 'them' : 'it'}`} so that consumers of your package can use the typescript definitions.`);
      }
    } else {
      throw new Error('Failed to build definition files.');
    }
  } catch (e) {
    if (e != null && typeof e === 'object') {
      if ('stdout' in e && e.stdout != null) {
        report.error(`Errors found when building definition files:\n${e.stdout.toString()}`);
      } else if ('message' in e && typeof e.message === 'string') {
        report.error(e.message);
      } else {
        throw e;
      }
    } else {
      throw e;
    }
    throw new Error('Failed to build definition files.');
  }
}
//# sourceMappingURL=typescript.js.map